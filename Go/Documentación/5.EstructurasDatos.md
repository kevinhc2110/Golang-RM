# Estructuras de datos en Go

## 1. Arrays

Los arrays son estructuras de tamaño fijo que almacenan elementos del mismo tipo.

**1.1 Arreglos unidimensionales:**

```go
var arreglo [5]int // Arreglo de 5 enteros
arreglo[0] = 10

```

**1.2 Arreglos multidimensionales:**

```go
var matriz [3][4]int // Matriz de 3x4 enteros
matriz[0][1] = 7

```

---

## 2. Slices

Los slices son una capa sobre los arrays que permiten una mayor flexibilidad, ya que su tamaño puede cambiar dinámicamente.(Tipo de dato)

```go
slice := []int{1, 2, 3} // Crear un slice
slice = append(slice, 4) // Agregar un elemento

fmt.Println(slice) // [1 2 3 4]

var slice []int // Slice vacío
slice = append(slice, 1) // Agregar un elemento
```

---

## 3. Structs

Las estructuras son colecciones de campos que pueden contener diferentes tipos de datos. Se usan comúnmente para representar entidades. (Tipo de dato)

```go
type Persona struct {
    Nombre string
    Edad   int
}

func main() {
    p := Persona{Nombre: "Juan", Edad: 30}
    fmt.Println(p.Nombre) // Imprime "Juan"
}

```

---

## 4. Diccionarios o Mapas

Los mapas son colecciones desordenadas de pares clave-valor, donde las claves deben ser únicas.

```go
var mapa = make(map[string]int)
mapa["clave"] = 10
valor := mapa["clave"]

```

---

## 5. Pilas(Stacks)

Las pilas siguen el principio Last In, First Out (LIFO), donde el último elemento agregado es el primero en ser eliminado.

**5.1. Implementación con arrays:**

```go
type Pila struct {
    elementos []int
}

func (p *Pila) Apilar(valor int) {
    p.elementos = append(p.elementos, valor)
}

func (p *Pila) Desapilar() int {
    if len(p.elementos) == 0 {
        return 0 // O manejar el error
    }
    valor := p.elementos[len(p.elementos)-1]
    p.elementos = p.elementos[:len(p.elementos)-1]
    return valor
}
```

**5.2 Implementación con listas:**

Alternativamente, una pila puede ser implementada usando una lista enlazada.

**5.3 Operaciones básicas:**

- push(elemento): Agrega un elemento a la pila.
- pop(): Elimina y devuelve el último elemento agregado.
- top(): Devuelve el último elemento agregado sin eliminarlo.
- empty(): Indica si la pila está vacía.

---

## 6. Colas(Queues)

Las colas siguen el principio First In, First Out (FIFO), donde el primer elemento agregado es el primero en ser eliminado.

**6.1. Colas simples:**

```go
type Cola struct {
    elementos []int
}

func (c *Cola) Encolar(valor int) {
    c.elementos = append(c.elementos, valor)
}

func (c *Cola) Desencolar() int {
    if len(c.elementos) == 0 {
        return 0 // O manejar el error
    }
    valor := c.elementos[0]
    c.elementos = c.elementos[1:]
    return valor
}

```

**6.2.Colas dobles (Deque):**

```go
type Deque struct {
    elementos []int
}

func (d *Deque) EncolarFrente(valor int) {
    d.elementos = append([]int{valor}, d.elementos...)
}

func (d *Deque) EncolarFinal(valor int) {
    d.elementos = append(d.elementos, valor)
}

func (d *Deque) DesencolarFrente() int {
    if len(d.elementos) == 0 {
        return 0 // O manejar el error
    }
    valor := d.elementos[0]
    d.elementos = d.elementos[1:]
    return valor
}

func (d *Deque) DesencolarFinal() int {
    if len(d.elementos) == 0 {
        return 0 // O manejar el error
    }
    valor := d.elementos[len(d.elementos)-1]
    d.elementos = d.elementos[:len(d.elementos)-1]
    return valor
}

```

**6.3. Colas de prioridad:**

```go
import "container/heap"

type PrioridadElemento struct {
    valor    int
    prioridad int
}

type PrioridadHeap []PrioridadElemento

func (h PrioridadHeap) Len() int           { return len(h) }
func (h PrioridadHeap) Less(i, j int) bool { return h[i].prioridad > h[j].prioridad }
func (h PrioridadHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *PrioridadHeap) Push(x interface{}) {
    *h = append(*h, x.(PrioridadElemento))
}

func (h *PrioridadHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

```

**6.4 Operaciones básicas:**

- enqueue(elemento): Agrega un elemento a la cola.
- dequeue(): Elimina y devuelve el primer elemento agregado.
- front(): Devuelve el primer elemento agregado sin eliminarlo.
- empty(): Indica si la cola está vacía.

---

## 7. Lista Enlazada

Una lista enlazada se puede crear usando structs y punteros.

**7.1. Listas enlazadas simples:**

```go
type Nodo struct {
    valor int
    siguiente *Nodo
}

```

**7.2. Listas dobles enlazadas:**

```go
type NodoDoble struct {
    valor int
    siguiente *NodoDoble
    anterior *NodoDoble
}

```

**7.3. Listas circulares:**

```go
type NodoCircular struct {
    valor int
    siguiente *NodoCircular
}

```

---

## 8. Conjuntos

Un conjunto es una colección de elementos únicos, donde no se permiten duplicados. En muchas implementaciones de lenguajes de programación, los conjuntos no tienen un orden definido entre sus elementos.

Go no tiene un tipo de conjunto (set) incorporado, pero puedes implementarlo usando mapas.

**8.1.Conjuntos matemáticos:**

```go
type Conjunto map[int]struct{}

func nuevoConjunto() Conjunto {
    return make(Conjunto)
}

func (c Conjunto) agregar(valor int) {
    c[valor] = struct{}{}
}

func (c Conjunto) contiene(valor int) bool {
    _, existe := c[valor]
    return existe
}

```

**8.2. Conjuntos no ordenados:**

Implementados usando mapas (map), los conjuntos son no ordenados.

---

## 9. Arboles

Un árbol es una estructura de datos jerárquica que consiste en nodos conectados por aristas. Cada nodo puede tener un número variable de nodos hijos. Un árbol no tiene ciclos, lo que significa que no hay una forma de empezar desde un nodo y volver al mismo a través de las aristas.

**9.1. Árbol binario:**

```go
type Nodo struct {
    valor int
    izquierda *Nodo
    derecha *Nodo
}
```

**9.2. Árbol AVL:**

```go
type NodoAVL struct {
    valor int
    izquierda *NodoAVL
    derecha *NodoAVL
    altura int
}

```

**9.3. Árbol B:**

Un árbol B es un árbol auto-balanceado que mantiene datos ordenados y permite operaciones en tiempo logarítmico.

**9.4. Árbol rojo-negro:**

Un árbol rojo-negro es otro tipo de árbol binario auto-balanceado.

## 10. Grafos

**10.1 Grafos dirigidos:**

```go
type GrafoDirigido struct {
    nodos map[string][]string
}

```

**10.2 Grafos no dirigidos:**

```go
type GrafoNoDirigido struct {
    nodos map[string][]string
}

```

**10.3 Matrices de adyacencia:**

```go
type MatrizAdyacencia [][]bool

```

**10.4 Listas de adyacencia:**

```go
type ListaAdyacencia map[string][]string

```

## 11. Genéricos
