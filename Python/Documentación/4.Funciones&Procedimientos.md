# 4. Funciones y Procedimientos en Python

## 4.1. Definición de Funciones

- ### Definición de una función

  Se utiliza la palabra clave def, seguida del nombre de la función, parámetros y el cuerpo de la función.

  ```py
  def nombre_funcion(param1, param2):
  # Cuerpo de la función
  pass

  ```

- ### Parámetros

  Los parámetros se definen entre paréntesis y pueden ser múltiples.

  ```py
  def suma(a, b):
  return a + b

  ```

- ### Tipos de retorno

  Una función puede retornar uno o varios valores.

  ```py
  def operaciones(a, b):
  suma = a + b
  resta = a - b
  return suma, resta

  ```

- ### Valores por defecto

  Python soporta valores por defecto para parámetros.

  ```py
  def greet(name="Invitado"):
  return f"Hola, {name}"

  ```

---

## 4.2. Ámbito de Funciones

- ### Alcance local y global

  - **Local:** Las variables declaradas dentro de una función solo son accesibles dentro de esa función.
  - **Global:** Las variables declaradas fuera de una función son accesibles en cualquier parte del archivo (y en otros archivos si se exportan).

    ```py
    global_var = 10  # Variable global

    def ejemplo():
        local_var = 5  # Variable local
        print(global_var)  # Acceso a variable global

    ```

- ### Variables estáticas

  Python no tiene variables estáticas en el sentido tradicional. Sin embargo, se puede usar variables globales o técnicas como las funciones de cierre (closures) para mantener el estado.

---

## 4.3. Valor y Referencia

- ### Paso por valor

  Python pasa los parámetros por referencia de objeto, lo que significa que los cambios en un objeto mutable dentro de la función afectan el objeto original.

  ```py
  def incrementar(valor):
      valor[0] += 1

  num = [10]
  incrementar(num)
  print(num[0])  # Output: 11

  ```

  Para tipos inmutables como números y cadenas, el comportamiento es similar al paso por valor.

  ```py
  def incrementar(valor):
      valor += 1

  num = 10
  incrementar(num)
  print(num)  # Output: 10, el valor original no cambia

  ```

---

## 4.4. Recursividad

Una función es recursiva si se llama a sí misma. Debe tener una condición de parada para evitar una llamada infinita.

```py
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

```

## 4.5. Sobrecarga de Funciones

Python no soporta sobrecarga de funciones en el sentido tradicional. Se pueden usar valores predeterminados o `*args` `**kwargs` para manejar múltiples parámetros.

```py
def suma(a, b):
    return a + b

def suma_float(a, b):
    return a + b

```

---

## 4.6. Funciones Anónimas (Lambda)

- ### Funciones anónimas

  Las funciones anónimas, también conocidas como lambdas, son funciones sin nombre. Se utilizan para definir funciones inline.

  ```py
  suma = lambda a, b: a + b
  print(suma(3, 4))  # Output: 7

  ```

- ### Closures

  Un closure es una función anónima que captura y puede modificar variables de su entorno.

  ```go
  def contador():
  i = 0
  return lambda: (i := i + 1)

  c = contador()
  print(c())  # Output: 1
  print(c())  # Output: 2

  ```

---

## 4.7. Callbacks

Un callback es una función que se pasa como argumento a otra función y se ejecuta dentro de esa función.

```py
def procesar_datos(datos, callback):
    for dato in datos:
        callback(dato)

def print_dato(d):
    print("Dato:", d)

datos = [1, 2, 3, 4, 5]
procesar_datos(datos, print_dato)

```

---

## 4.8. Funciones con finally

La palabra clave finally se usa para ejecutar un bloque de código sin importar si se produjo una excepción o no, similar al defer en Go.

```py
def abrir_archivo(nombre):
    try:
        archivo = open(nombre, 'r')
        # Procesar el archivo
    finally:
        archivo.close()

```

---

## 4.9. Funciones como Parámetros

En Python, puedes pasar funciones como parámetros a otras funciones, lo que permite una gran flexibilidad y reutilización del código.

```go
def aplicar_operacion(a, b, operacion):
    return operacion(a, b)

def suma(x, y):
    return x + y

def resta(x, y):
    return x - y

resultado_suma = aplicar_operacion(5, 3, suma)
print("Resultado de la suma:", resultado_suma)  # Imprime "Resultado de la suma: 8"

resultado_resta = aplicar_operacion(5, 3, resta)
print("Resultado de la resta:", resultado_resta)  # Imprime "Resultado de la resta: 2"

```

---

## 4.10. Funciones de Orden Superior

Las funciones de orden superior son aquellas que pueden recibir otras funciones como argumentos o devolver funciones como resultado.

```py
def operar(a, b, operacion):
    return operacion(a, b)

def main():
    suma = lambda x, y: x + y
    resultado = operar(5, 3, suma)
    print(resultado)  # Output: 8

```

---

## 4.11. Iteradores e Iterables

- ### Iterables

  Un iterable es cualquier objeto en Python que puede ser iterado. Los ejemplos más comunes son listas, tuplas, diccionarios y conjuntos.

  ```py
  lista = [1, 2, 3, 4]
  for elemento in lista:
      print(elemento)

  ```

- ### Iteradores

  Un iterador es un objeto que implementa los métodos `__iter__()` y `__next__()`. Los iteradores permiten recorrer los elementos de un iterable.

  ```py
  numeros = iter([1, 2, 3, 4])
  print(next(numeros))  # Output: 1
  print(next(numeros))  # Output: 2

  ```

- ### Iterar con zip

  La función zip combina varios iterables en tuplas.

  ```py
  nombres = ["Ana", "Luis", "Juan"]
  edades = [25, 30, 22]

  for nombre, edad in zip(nombres, edades):
      print(f"{nombre} tiene {edad} años")

  ```

- ### Iterar con enumerate

  La función enumerate añade un índice a cada elemento del iterable.

  ```py
  frutas = ["manzana", "banana", "cereza"]

  for indice, fruta in enumerate(frutas):
      print(f"Índice {indice}: {fruta}")

  ```
