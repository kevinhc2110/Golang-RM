# Funciones y Procedimientos en Go

## 1. Definición de Funciones

**1.1. Definición de una función:**

Se utiliza la palabra clave func, seguida del nombre de la función, parámetros y tipo de retorno.

```go
func nombreFuncion(param1 tipo1, param2 tipo2) tipoRetorno {
    // Cuerpo de la función
}

```

**1.2. Parámetros:**

Los parámetros se definen entre paréntesis y pueden ser múltiples.

```go
func suma(a int, b int) int {
    return a + b
}

```

**1.3. Tipos de retorno:**

Una función puede retornar uno o varios valores.

```go
func operaciones(a int, b int) (int, int) {
    suma := a + b
    resta := a - b
    return suma, resta
}

```

**1.4. Valores por defecto:**

Go no soporta valores por defecto para parámetros. Todos los argumentos deben ser proporcionados al llamar a la función.

---

## 2. Ámbito de Funciones

**2.1. Alcance local y global:**

- Local: Las variables declaradas dentro de una función solo son accesibles dentro de esa función.
- Global: Las variables declaradas fuera de una función son accesibles en cualquier parte del archivo (y en otros archivos si se exportan).

```go
var globalVar = 10 // Variable global

func ejemplo() {
    var localVar = 5 // Variable local
    fmt.Println(globalVar) // Acceso a variable global
}

```

**2.2. Variables estáticas:**

Go no tiene variables estáticas en el sentido tradicional de C/C++. Sin embargo, puedes usar variables globales para mantener el estado entre llamadas a funciones.

---

## 3. Valor y Referencia

**3.1. Paso por valor:**

En Go, los parámetros se pasan a las funciones por valor, lo que significa que se pasa una copia del valor. Los cambios en el parámetro dentro de la función no afectan al valor original fuera de la función.

```go
func incrementar(valor int) {
    valor++
}

func main() {
    num := 10
    incrementar(num)
    fmt.Println(num) // Output: 10, el valor original no cambia
}

```

**3.2. Paso por referencia usando punteros:**

Para modificar el valor original dentro de una función, se puede pasar un puntero al valor en lugar del valor en sí. Esto se hace usando el operador & para obtener la dirección de una variable y el operador \* para desreferenciar el puntero.

```go
func incrementar(valor *int) {
    *valor++
}

func main() {
    num := 10
    incrementar(&num)
    fmt.Println(num) // Output: 11, el valor original cambia
}

```

---

## 4. Recursividad

Una función es recursiva si se llama a sí misma. Debe tener una condición de parada para evitar una llamada infinita.

```go
func factorial(n int) int {
    if n == 0 {
        return 1
    }
    return n * factorial(n-1)
}

```

## 5. Sobrecarga de Funciones

Go no soporta sobrecarga de funciones (es decir, múltiples funciones con el mismo nombre pero diferentes parámetros). Debes usar nombres de funciones diferentes.

```go
func suma(a int, b int) int {
    return a + b
}

func sumaFloat(a float64, b float64) float64 {
    return a + b
}

```

---

## 6. Funciones Anónimas (Lambda)

**6.1. Funciones anónimas:**

Las funciones anónimas, también conocidas como lambdas, son funciones sin nombre. Se utilizan para definir funciones inline.

```go
func main() {
    suma := func(a, b int) int {
        return a + b
    }
    fmt.Println(suma(3, 4)) // Output: 7
}

```

**6.2. Closures:**

Un closure es una función anónima que captura y puede modificar variables de su entorno.

```go
func contador() func() int {
    i := 0
    return func() int {
        i++
        return i
    }
}

func main() {
    c := contador()
    fmt.Println(c()) // Output: 1
    fmt.Println(c()) // Output: 2
}

```

---

## 7. Callbacks

Un callback es una función que se pasa como argumento a otra función y se ejecuta dentro de esa función.

```go
func procesarDatos(datos []int, callback func(int)) {
    for _, dato := range datos {
        callback(dato)
    }
}

func main() {
    datos := []int{1, 2, 3, 4, 5}
    procesarDatos(datos, func(d int) {
        fmt.Println("Dato:", d)
    })
}

```

---

## 8. Funciones con defer

La palabra clave defer se usa para posponer la ejecución de una función hasta que la función que la contiene termine de ejecutarse. Es útil para realizar tareas de limpieza, como cerrar archivos o liberar recursos.

```go
func abrirArchivo(nombre string) (*os.File, error) {
    archivo, err := os.Open(nombre)
    if err != nil {
        return nil, err
    }
    // `defer` garantiza que el archivo se cerrará al final de la función
    defer archivo.Close()
    return archivo, nil
}

func main() {
    archivo, err := abrirArchivo("ejemplo.txt")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    // Procesar el archivo
}

```

---

## 9. Funciones como Parámetros

En Go, puedes pasar funciones como parámetros a otras funciones, lo que permite una gran flexibilidad y reutilización del código.

```go
func aplicarOperacion(a int, b int, operacion func(int, int) int) int {
    return operacion(a, b)
}

func suma(x int, y int) int {
    return x + y
}

func resta(x int, y int) int {
    return x - y
}

func main() {
    resultadoSuma := aplicarOperacion(5, 3, suma)
    fmt.Println("Resultado de la suma:", resultadoSuma) // Output: Resultado de la suma: 8

    resultadoResta := aplicarOperacion(5, 3, resta)
    fmt.Println("Resultado de la resta:", resultadoResta) // Output: Resultado de la resta: 2
}

```

---

## 10. Funciones de Orden Superior

Las funciones de orden superior son aquellas que pueden recibir otras funciones como argumentos o devolver funciones como resultado.

```go
func operar(a int, b int, operacion func(int, int) int) int {
    return operacion(a, b)
}

func main() {
    suma := func(x int, y int) int {
        return x + y
    }
    resultado := operar(5, 3, suma)
    fmt.Println(resultado) // Output: 8
}

```
